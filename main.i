# 1 "main.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "main.c"
# 20 "main.c"
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 1 3
# 10 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/ieeefp.h" 1 3
# 11 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 2 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/_ansi.h" 1 3
# 15 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/_ansi.h" 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/newlib.h" 1 3
# 16 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/_ansi.h" 2 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/config.h" 1 3



# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/ieeefp.h" 1 3
# 5 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/config.h" 2 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/features.h" 1 3
# 6 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/config.h" 2 3
# 17 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/_ansi.h" 2 3
# 12 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 2 3




# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/lib/gcc/arm-none-eabi/5.3.0/include/stddef.h" 1 3 4
# 216 "/Users/michellechiu/Desktop/CS2261/devkitARM/lib/gcc/arm-none-eabi/5.3.0/include/stddef.h" 3 4

# 216 "/Users/michellechiu/Desktop/CS2261/devkitARM/lib/gcc/arm-none-eabi/5.3.0/include/stddef.h" 3 4
typedef unsigned int size_t;
# 328 "/Users/michellechiu/Desktop/CS2261/devkitARM/lib/gcc/arm-none-eabi/5.3.0/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 17 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 2 3

# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 1 3
# 13 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/_ansi.h" 1 3
# 14 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 2 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/lib/gcc/arm-none-eabi/5.3.0/include/stddef.h" 1 3 4
# 149 "/Users/michellechiu/Desktop/CS2261/devkitARM/lib/gcc/arm-none-eabi/5.3.0/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 15 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 2 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/_types.h" 1 3
# 12 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/_types.h" 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/_types.h" 1 3






# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/_default_types.h" 1 3
# 27 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef signed char __int8_t;

typedef unsigned char __uint8_t;
# 41 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef short int __int16_t;

typedef short unsigned int __uint16_t;
# 63 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long int __int32_t;

typedef long unsigned int __uint32_t;
# 89 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long long int __int64_t;

typedef long long unsigned int __uint64_t;
# 120 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef signed char __int_least8_t;

typedef unsigned char __uint_least8_t;
# 146 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef short int __int_least16_t;

typedef short unsigned int __uint_least16_t;
# 168 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long int __int_least32_t;

typedef long unsigned int __uint_least32_t;
# 186 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef long long int __int_least64_t;

typedef long long unsigned int __uint_least64_t;
# 200 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/_default_types.h" 3
typedef int __intptr_t;

typedef unsigned int __uintptr_t;
# 8 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/_types.h" 2 3
# 13 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/_types.h" 2 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/lock.h" 1 3




# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/lib/gcc/arm-none-eabi/5.3.0/include/stdint.h" 1 3 4
# 9 "/Users/michellechiu/Desktop/CS2261/devkitARM/lib/gcc/arm-none-eabi/5.3.0/include/stdint.h" 3 4
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdint.h" 1 3 4
# 13 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdint.h" 3 4
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/_intsup.h" 1 3 4
# 14 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdint.h" 2 3 4






typedef __int8_t int8_t ;
typedef __uint8_t uint8_t ;




typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;




typedef __int16_t int16_t ;
typedef __uint16_t uint16_t ;




typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;




typedef __int32_t int32_t ;
typedef __uint32_t uint32_t ;




typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;




typedef __int64_t int64_t ;
typedef __uint64_t uint64_t ;




typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;
# 74 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef int int_fast8_t;
  typedef unsigned int uint_fast8_t;
# 84 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef int int_fast16_t;
  typedef unsigned int uint_fast16_t;
# 94 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef int int_fast32_t;
  typedef unsigned int uint_fast32_t;
# 104 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef long long int int_fast64_t;
  typedef long long unsigned int uint_fast64_t;
# 153 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef long long int intmax_t;
# 162 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdint.h" 3 4
  typedef long long unsigned int uintmax_t;






typedef __intptr_t intptr_t;
typedef __uintptr_t uintptr_t;
# 10 "/Users/michellechiu/Desktop/CS2261/devkitARM/lib/gcc/arm-none-eabi/5.3.0/include/stdint.h" 2 3 4
# 6 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/lock.h" 2 3

typedef int32_t _LOCK_T;

struct __lock_t {
 _LOCK_T lock;
 uint32_t thread_tag;
 uint32_t counter;
};

typedef struct __lock_t _LOCK_RECURSIVE_T;

extern void __libc_lock_init(_LOCK_T *lock);
extern void __libc_lock_init_recursive(_LOCK_RECURSIVE_T *lock);
extern void __libc_lock_close(_LOCK_T *lock);
extern void __libc_lock_close_recursive(_LOCK_RECURSIVE_T *lock);
extern void __libc_lock_acquire(_LOCK_T *lock);
extern void __libc_lock_acquire_recursive(_LOCK_RECURSIVE_T *lock);
extern void __libc_lock_release(_LOCK_T *lock);
extern void __libc_lock_release_recursive(_LOCK_RECURSIVE_T *lock);


extern int __libc_lock_try_acquire(_LOCK_T *lock);
extern int __libc_lock_try_acquire_recursive(_LOCK_RECURSIVE_T *lock);
# 14 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/_types.h" 2 3


typedef long _off_t;



typedef int __dev_t;



typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



__extension__ typedef long long _off64_t;







typedef long _fpos_t;
# 55 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/_types.h" 3
typedef signed int _ssize_t;
# 67 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/_types.h" 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/lib/gcc/arm-none-eabi/5.3.0/include/stddef.h" 1 3 4
# 357 "/Users/michellechiu/Desktop/CS2261/devkitARM/lib/gcc/arm-none-eabi/5.3.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 68 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 16 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 38 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct _reent;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 91 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 115 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 179 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                                          ;
  int (* _write) (struct _reent *, void *, const char *, int)

                                   ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _off_t _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 285 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 317 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 569 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];

  int _current_category;
  const char *_current_locale;

  int __sdidinit;

  void (* __cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;



  struct _atexit *_atexit;
  struct _atexit _atexit0;



  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 762 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);





  struct _reent * __getreent (void);
# 19 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 2 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/cdefs.h" 1 3
# 45 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/cdefs.h" 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/lib/gcc/arm-none-eabi/5.3.0/include/stddef.h" 1 3 4
# 46 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/sys/cdefs.h" 2 3
# 20 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 2 3
# 1 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/machine/stdlib.h" 1 3
# 21 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 2 3
# 29 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 3


typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;




typedef struct
{
  long long int quot;
  long long int rem;
} lldiv_t;




typedef int (*__compar_fn_t) (const void *, const void *);







int __locale_mb_cur_max (void);



void abort (void) __attribute__ ((__noreturn__));
int abs (int);
int atexit (void (*__func)(void));
double atof (const char *__nptr);



int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, __compar_fn_t _compar)



                                ;
void * calloc (size_t __nmemb, size_t __size) ;
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((__noreturn__));
void free (void *) ;
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);




long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size) ;
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *restrict, const char *restrict, size_t);
int _mbtowc_r (struct _reent *, wchar_t *restrict, const char *restrict, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *restrict, const char *restrict, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *restrict, const char *restrict, size_t, _mbstate_t *);
size_t wcstombs (char *restrict, const wchar_t *restrict, size_t);
size_t _wcstombs_r (struct _reent *, char *restrict, const wchar_t *restrict, size_t, _mbstate_t *);
# 124 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 3
void qsort (void * __base, size_t __nmemb, size_t __size, __compar_fn_t _compar);
int rand (void);
void * realloc (void * __r, size_t __size) ;




void srand (unsigned __seed);
double strtod (const char *restrict __n, char **restrict __end_PTR);
double _strtod_r (struct _reent *,const char *restrict __n, char **restrict __end_PTR);



float strtof (const char *restrict __n, char **restrict __end_PTR);







long strtol (const char *restrict __n, char **restrict __end_PTR, int __base);
long _strtol_r (struct _reent *,const char *restrict __n, char **restrict __end_PTR, int __base);
unsigned long strtoul (const char *restrict __n, char **restrict __end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *restrict __n, char **restrict __end_PTR, int __base);

int system (const char *__string);
# 161 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 3
void _Exit (int __status) __attribute__ ((__noreturn__));
# 180 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 3
char * __itoa (int, char *, int);
char * __utoa (unsigned, char *, int);
# 211 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 3
long long atoll (const char *__nptr);







long long llabs (long long);
lldiv_t lldiv (long long __numer, long long __denom);
long long strtoll (const char *restrict __n, char **restrict __end_PTR, int __base);







unsigned long long strtoull (const char *restrict __n, char **restrict __end_PTR, int __base);
# 246 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 3
char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) ;
void * _calloc_r (struct _reent *, size_t, size_t) ;
void _free_r (struct _reent *, void *) ;
void * _realloc_r (struct _reent *, void *, size_t) ;
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);
# 279 "/Users/michellechiu/Desktop/CS2261/devkitARM/arm-none-eabi/include/stdlib.h" 3
extern long double strtold (const char *restrict, char **restrict);




# 21 "main.c" 2
# 1 "myLib.h" 1




# 4 "myLib.h"
typedef unsigned short u16;
# 40 "myLib.h"
extern unsigned short *videoBuffer;

extern unsigned short *frontBuffer;
extern unsigned short *backBuffer;




void setPixel3(int row, int col, unsigned short color);
void drawRect3(int row, int col, int height, int width, unsigned short color);
void fillScreen3(unsigned short color);
void drawImage3(const unsigned short* image, int row, int col, int height, int width);


void setPixel4(int row, int col, unsigned char colorIndex);
void drawRect4(int row, int col, int height, int width, unsigned char colorIndex);
void fillScreen4(unsigned char color);

void drawBackgroundImage4(const unsigned short* image);
void drawImage4(const unsigned short* image, int row, int col, int height, int width);
void drawSubImage4(const unsigned short* sourceImage, int sourceRow, int sourceCol,
       int row, int col, int height, int width);

void loadPalette(const unsigned short* palette);
void initialize();

void waitForVblank();
void flipPage();
# 88 "myLib.h"
extern unsigned int oldButtons;
extern unsigned int buttons;
# 98 "myLib.h"
void DMANow(int channel, volatile const void* source, volatile void* destination, unsigned int control);






typedef volatile struct
{
        volatile const void *src;
        volatile void *dst;
        volatile unsigned int cnt;
} DMA;

extern DMA *dma;
# 137 "myLib.h"
enum {IDLE, CHASE, FLEE};
# 234 "myLib.h"
typedef struct { u16 tileimg[8192]; } charblock;
typedef struct { u16 tilemap[1024]; } screenblock;
# 294 "myLib.h"
typedef struct{
    unsigned short attr0;
    unsigned short attr1;
    unsigned short attr2;
    unsigned short fill;
}OBJ_ATTR;

typedef struct {
    int row;
    int col;
} Sprite;
# 22 "main.c" 2
# 1 "sound.h" 1



void setupSounds();
void playSoundA(const unsigned char* sound, int length, int frequency, int loops);
void playSoundB(const unsigned char* sound, int length, int frequency, int loops);
void muteSound();
void unmuteSound();
void stopSound();

void setupInterrupts();
void interruptHandler();

typedef struct{
    const unsigned char* data;
    int length;
    int frequency;
    int isPlaying;
    int loops;
    int duration;
    int priority;
    int vbCount;
} SOUND;
# 23 "main.c" 2
# 1 "startscreen.h" 1
# 22 "startscreen.h"
extern const unsigned short startscreenTiles[17792];


extern const unsigned short startscreenMap[1024];


extern const unsigned short startscreenPal[256];
# 24 "main.c" 2
# 1 "storyscreen.h" 1
# 22 "storyscreen.h"
extern const unsigned short storyscreenTiles[32768];


extern const unsigned short storyscreenMap[1024];


extern const unsigned short storyscreenPal[256];
# 25 "main.c" 2
# 1 "storyscreen2.h" 1
# 22 "storyscreen2.h"
extern const unsigned short storyscreen2Tiles[17344];


extern const unsigned short storyscreen2Map[1024];


extern const unsigned short storyscreen2Pal[256];
# 26 "main.c" 2
# 1 "color.h" 1
# 22 "color.h"
extern const unsigned short colorTiles[13536];


extern const unsigned short colorMap[1024];


extern const unsigned short colorPal[256];
# 27 "main.c" 2
# 1 "instructions.h" 1
# 22 "instructions.h"
extern const unsigned short instructionsTiles[14496];


extern const unsigned short instructionsMap[1024];


extern const unsigned short instructionsPal[256];
# 28 "main.c" 2
# 1 "instructions2.h" 1
# 22 "instructions2.h"
extern const unsigned short instructions2Tiles[32768];


extern const unsigned short instructions2Map[1024];


extern const unsigned short instructions2Pal[256];
# 29 "main.c" 2
# 1 "gamescreen.h" 1
# 22 "gamescreen.h"
extern const unsigned short gamescreenTiles[15328];


extern const unsigned short gamescreenMap[1024];


extern const unsigned short gamescreenPal[256];
# 30 "main.c" 2
# 1 "pausescreen.h" 1
# 22 "pausescreen.h"
extern const unsigned short pausescreenTiles[32768];


extern const unsigned short pausescreenMap[1024];


extern const unsigned short pausescreenPal[256];
# 31 "main.c" 2
# 1 "losescreen.h" 1
# 22 "losescreen.h"
extern const unsigned short losescreenTiles[32768];


extern const unsigned short losescreenMap[1024];


extern const unsigned short losescreenPal[256];
# 32 "main.c" 2
# 1 "kirby_sprites.h" 1
# 21 "kirby_sprites.h"
extern const unsigned short kirby_spritesTiles[16384];


extern const unsigned short kirby_spritesPal[256];
# 33 "main.c" 2
# 1 "stageonebackground.h" 1
# 22 "stageonebackground.h"
extern const unsigned short stageonebackgroundTiles[14672];


extern const unsigned short stageonebackgroundMap[1024];


extern const unsigned short stageonebackgroundPal[256];
# 34 "main.c" 2
# 1 "jungle.h" 1
# 22 "jungle.h"
extern const unsigned short jungleTiles[160];


extern const unsigned short jungleMap[1024];


extern const unsigned short junglePal[256];
# 35 "main.c" 2
# 1 "winscreen.h" 1
# 22 "winscreen.h"
extern const unsigned short winscreenTiles[32768];


extern const unsigned short winscreenMap[1024];


extern const unsigned short winscreenPal[256];
# 36 "main.c" 2
# 1 "story-mode.h" 1
# 20 "story-mode.h"
extern const unsigned char story_mode[8763264];
# 37 "main.c" 2
# 1 "opening.h" 1
# 20 "opening.h"
extern const unsigned char opening[2012812];
# 38 "main.c" 2
# 1 "gameover.h" 1
# 20 "gameover.h"
extern const unsigned char gameover[44416];
# 39 "main.c" 2
# 1 "bubblyclouds.h" 1
# 20 "bubblyclouds.h"
extern const unsigned char bubblyclouds[1212192];
# 40 "main.c" 2
# 1 "jump.h" 1
# 20 "jump.h"
extern const unsigned char jump[2857];
# 41 "main.c" 2
# 1 "hit.h" 1
# 20 "hit.h"
extern const unsigned char hit[11232];
# 42 "main.c" 2
# 1 "winner.h" 1
# 20 "winner.h"
extern const unsigned char winner[42240];
# 43 "main.c" 2
# 1 "lifelost.h" 1
# 20 "lifelost.h"
extern const unsigned char lifelost[52224];
# 44 "main.c" 2

unsigned int buttons;
unsigned int oldButtons;

int hOff = 0;
int vOff = 0;

OBJ_ATTR shadowOAM[128];




typedef struct {
    int row;
    int col;
    int rdel;
    int racc;
    int cdel;
    int width;
    int height;
    int kirbyDirection;
    int attacking;
    int color;
} KIRBY;

typedef struct {
    int row;
    int col;
    int height;
    int width;
    int active;
} PLATFORM;

typedef struct {
    int row;
    int col;
    int height;
    int width;
    int active;
} ORB;

typedef struct {
    int row;
    int col;
    int height;
    int width;
    int active;
    int direction;
} ENEMY;

typedef struct {
    int row;
    int col;
    int height;
    int width;
    int active;
} ROCKET;

typedef struct {
    int row;
    int col;
    int height;
    int width;
    int active;
} ARROW;

typedef struct {
    int row;
    int col;
    int width;
    int height;
    int active;
} LIFE;

KIRBY kirby;
ENEMY boo;
LIFE playerLives[3];

int numPlatforms = 20;
PLATFORM platforms[20];

int numSpikePlatforms = 10;
PLATFORM spikePlatforms[10];

int numOrbs = 5;
ORB orbs[5];

int numRockets = 10;
ROCKET rockets[10];

int numArrows = 15;
ARROW arrows[15];

int lives;
int state;
int direction;
int timer;
int jumpTimer;
int collisionTimer;
int firstCollision;
int numOrbsCollected;
int gameStarted;
int cheatMode;

void hideSprites();
void initialize();
void updateBullet();
void start();
void story();
void story2();
void color();
void instructions();
void instructions2();
void game();
void pause();
void win();
void lose();
void goToStart();
void goToStory();
void goToStory2();
void goToColor();
void goToInstructions();
void goToInstructions2();
void goToGame();
void goToPause();
void goToLose();
void updatePlayer();
void generatePlatforms();
void generateRockets();
void generateOrbs();
void unpauseBoo();
void moveActivePlatforms();
void moveActiveOrbs();
void moveActiveBoo();
void moveActiveRockets();
void moveActiveArrows();
void attackEnemies();
void collisionCheckKirbyPlatform();
void collisionCheckKirbyOrb();
void collisionCheckKirbyRocket();
void collisionCheckKirbyBoo();
void collisionCheckArrowsBoo();
void checkKirbyOutOfBounds();
void checkWin();
void checkLose();

enum { STARTSCREEN, STORYSCREEN, STORYSCREEN2, COLOR, INSTRUCTIONS, INSTRUCTIONS2,
    GAMESCREEN, PAUSESCREEN, LOSESCREEN, WINSCREEN };

int main() {

    goToStart();

 while(1) {
        oldButtons = buttons;
        buttons = *(volatile unsigned int *)0x04000130;

        switch(state) {
            case STARTSCREEN:
                start();
                break;
            case STORYSCREEN:
                story();
                break;
            case STORYSCREEN2:
                story2();
                break;
            case COLOR:
                color();
                break;
            case INSTRUCTIONS:
                instructions();
                break;
            case INSTRUCTIONS2:
                instructions2();
                break;
            case GAMESCREEN:
                game();
                break;
            case PAUSESCREEN:
                pause();
                break;
            case LOSESCREEN:
                lose();
                break;
            case WINSCREEN:
                win();
                break;
        }

        *(volatile unsigned short *)0x04000010 = hOff;
        *(volatile unsigned short *)0x04000012 = vOff;

        DMANow(3, shadowOAM, ((OBJ_ATTR*)(0x7000000)), 128 * 4);

  waitForVblank();
 }
}


void hideSprites() {
    for (int i=0; i<128; i++) {
        shadowOAM[i].attr0 = (2 << 8);
    }
    DMANow(3, shadowOAM, ((OBJ_ATTR*)(0x7000000)), 128 * 4);
}

void initialize() {
    lives = 3;
    timer = 0;
    jumpTimer = 0;
    collisionTimer = 0;
    firstCollision = 0;
    gameStarted = 1;
    numOrbsCollected = 0;
    cheatMode = 0;

    DMANow(3, kirby_spritesPal, ((unsigned short*)(0x5000200)), 256);
    DMANow(3, kirby_spritesTiles, &((charblock *)0x6000000)[4], (32768 / 2));

    kirby.width = 24;
    kirby.height = 26;
    kirby.rdel = 0;
    kirby.racc = 30;
    kirby.cdel = 1;
    kirby.row = ((35) << 8);
    kirby.col = ((240/2-kirby.height/2) << 8);
    kirby.kirbyDirection = 0;
    kirby.attacking = 12;
    kirby.color = 0;

    for(int i = 0; i < numPlatforms; i++) {
        platforms[i].row = 0;
        int randomCol = rand() % ((208) + 1);
        platforms[i].col = randomCol;
        platforms[i].active = 0;
        platforms[i].width = 29;
        platforms[i].height = 22;
    }

    for (int o = 0; o < numOrbs; o++) {
        orbs[o].row = 0;
        int randomCol = rand() % (6);
        orbs[o].col = randomCol;
        orbs[o].active = 0;
        orbs[o].height = 15;
        orbs[o].width = 16;
    }

    boo.row = 10;
    boo.col = 30;
    boo.height = 15;
    boo.width = 25;
    boo.active = 1;
    boo.direction = 1;

    for (int r=0; r<numRockets; r++) {
        rockets[r].row = boo.row;
        rockets[r].col = boo.col;
        rockets[r].active = 0;
        rockets[r].height = 24;
        rockets[r].width = 15;
    }

    for (int a=0; a<numArrows; a++) {
        arrows[a].row = ((kirby.row) >> 8);
        arrows[a].col = ((kirby.col) >> 8);
        arrows[a].active = 0;
        arrows[a].height = 10;
        arrows[a].width = 4;
    }

    int lifeCol = 0;
    for (int l=0; l<lives; l++) {
        playerLives[l].row = 3;
        playerLives[l].col = (lifeCol*21)+5;
        playerLives[l].width = 27;
        playerLives[l].height = 22;
        playerLives[l].active = 1;
        lifeCol++;
    }

    for(int s = 0; s < numSpikePlatforms; s++) {
        spikePlatforms[s].row = 0;
        int randomCol = rand() % ((208) + 1);
        spikePlatforms[s].col = randomCol;
        spikePlatforms[s].active = 0;
        spikePlatforms[s].width = 32;
        spikePlatforms[s].height = 16;
    }
    setupSounds();
    setupInterrupts();
    playSoundA(bubblyclouds, 1212192, 11025, 1);
}

void goToStart() {
    initialize();
    *(unsigned short *)0x4000000 = 0 | (1<<8) | (1 << 12);
    *(volatile unsigned short*)0x4000008 = 0 << 2 | 20 << 8 | 0<<14 | 1 << 7;
    hideSprites();
    loadPalette(startscreenPal);
    DMANow(3, startscreenTiles, &((charblock *)0x6000000)[0], (35584 / 2));
    DMANow(3, startscreenMap, &((screenblock *)0x6000000)[20], (2048 / 2));
    state = STARTSCREEN;
}

void start() {
    waitForVblank();
    if ((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
        goToStory();
    }
}

void goToStory() {
    *(volatile unsigned short*)0x4000008 = 0 << 2 | 25 << 8 | 0<<14 | 1 << 7;
    loadPalette(storyscreenPal);
    DMANow(3, storyscreenTiles, &((charblock *)0x6000000)[0], (65536 / 2));
    DMANow(3, storyscreenMap, &((screenblock *)0x6000000)[25], (2048 / 2));
    state = STORYSCREEN;
}

void story() {
    waitForVblank();
    if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
        goToStory2();
    }
}

void goToStory2() {
    *(volatile unsigned short*)0x4000008 = 0 << 2 | 24 << 8 | 0<<14 | 1 << 7;
    loadPalette(storyscreen2Pal);
    DMANow(3, storyscreen2Tiles, &((charblock *)0x6000000)[0], (34688 / 2));
    DMANow(3, storyscreen2Map, &((screenblock *)0x6000000)[24], (2048 / 2));
    state = STORYSCREEN2;
}

void story2() {
    waitForVblank();
    if ((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
        goToColor();
    }
}

void goToColor() {
    *(volatile unsigned short*)0x4000008 = 0 << 2 | 25 << 8 | 0<<14 | 1 << 7;
    loadPalette(colorPal);
    DMANow(3, colorTiles, &((charblock *)0x6000000)[0], (27072 / 2));
    DMANow(3, colorMap, &((screenblock *)0x6000000)[25], (2048 / 2));
    state = COLOR;
}

void color() {
    waitForVblank();
    shadowOAM[0].attr0 = 70 | (0 << 13) | (0 << 14);
    shadowOAM[0].attr1 = 110 | (2 << 14);
    shadowOAM[0].attr2 = (12)*32+(kirby.color);
    if ((!(~(oldButtons)&((1<<5))) && (~buttons & ((1<<5))))) {
        if (kirby.color >= 8) {
            kirby.color = kirby.color - 8;
        } else {
            kirby.color = 24;
        }
    } else if ((!(~(oldButtons)&((1<<4))) && (~buttons & ((1<<4))))) {
        if (kirby.color <= 16) {
            kirby.color = kirby.color + 8;
        } else {
            kirby.color = 0;
        }
    } else if ((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
        goToInstructions();
    }
}

void goToInstructions() {
    shadowOAM[0].attr0 = (2 << 8);
    *(volatile unsigned short*)0x4000008 = 0 << 2 | 22 << 8 | 0<<14 | 1 << 7;
    loadPalette(instructionsPal);
    DMANow(3, instructionsTiles, &((charblock *)0x6000000)[0], (28992 / 2));
    DMANow(3, instructionsMap, &((screenblock *)0x6000000)[22], (2048 / 2));
    state = INSTRUCTIONS;
}

void instructions() {
    shadowOAM[0].attr0 = (2 << 8);
    waitForVblank();
    if ((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
        goToInstructions2();
    }
}

void goToInstructions2() {
    shadowOAM[0].attr0 = (2 << 8);
    *(volatile unsigned short*)0x4000008 = 0 << 2 | 23 << 8 | 0<<14 | 1 << 7;
    loadPalette(instructions2Pal);
    DMANow(3, instructions2Tiles, &((charblock *)0x6000000)[0], (65536 / 2));
    DMANow(3, instructions2Map, &((screenblock *)0x6000000)[23], (2048 / 2));
    state = INSTRUCTIONS2;
}

void instructions2() {
    waitForVblank();
    if ((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
        goToGame();
    }
}

void goToGame() {
    *(unsigned short *)0x4000000 = 0 | (1<<8) | (1<<9) | (1 << 12);
    *(volatile unsigned short*)0x400000A = 1 << 2 | 30 << 8 | 0<<14;
    *(volatile unsigned short*)0x4000008 = 0 << 2 | 31 << 8 | 0<<14;
    loadPalette(junglePal);
    DMANow(3, stageonebackgroundTiles, &((charblock *)0x6000000)[1], (29344 / 2));
    DMANow(3, stageonebackgroundMap, &((screenblock *)0x6000000)[30], (2048 / 2));
    DMANow(3, jungleTiles, &((charblock *)0x6000000)[0], (320 /2));
    DMANow(3, jungleMap, &((screenblock *)0x6000000)[31], (2048 / 2));
    state = GAMESCREEN;
}

void game() {
    vOff--;
    timer++;
    jumpTimer++;
    collisionTimer++;



    shadowOAM[0].attr0 = (0xFF & ((kirby.row) >> 8)) | (0 << 13) | (0 << 14);
    shadowOAM[0].attr1 = (0x1FF & ((kirby.col) >> 8)) | (2 << 14);
    shadowOAM[0].attr2 = (kirby.attacking)*32+(kirby.color + kirby.kirbyDirection);

    for (int p = 1; p < numPlatforms+1; p++) {
        if (platforms[p-1].active == 0) {
            shadowOAM[p].attr0 = (2 << 8);
        } else {
            shadowOAM[p].attr0 = platforms[p-1].row | (0 << 13) | (0 << 14);
        }
        shadowOAM[p].attr1 = platforms[p-1].col | (2 << 14);
        shadowOAM[p].attr2 = (0)*32+(16);
    }

    for (int o = 22; o < numOrbs+22; o++) {
        if (orbs[o-22].active == 0) {
            shadowOAM[o].attr0 = (2 << 8);
        } else {
            shadowOAM[o].attr0 = orbs[o-22].row | (0 << 13) | (0 << 14);
        }
        shadowOAM[o].attr1 = orbs[o-22].col | (2 << 14);
        shadowOAM[o].attr2 = (0)*32+(24);
    }
    if (boo.active) {
        shadowOAM[45].attr0 = boo.row | (0 << 13) | (0 << 14);
    } else {
        shadowOAM[45].attr0 = (2 << 8);
    }
    shadowOAM[45].attr1 = boo.col | (2 << 14);
    if (boo.direction == 0) {
        shadowOAM[45].attr2 = (4)*32+(8);
    } else if (boo.direction == 1) {
        shadowOAM[45].attr2 = (8)*32+(8);
    } else if (boo.direction == 2) {
        shadowOAM[45].attr2 = (0)*32+(8);
    }


    for (int r = 46; r < 46+numRockets; r++) {
        if (rockets[r-46].active == 0) {
            shadowOAM[r].attr0 = (2 << 8);
        } else {
            shadowOAM[r].attr0 = rockets[r-46].row | (0 << 13) | (0 << 14);
        }
        shadowOAM[r].attr1 = rockets[r-46].col | (2 << 14);
        shadowOAM[r].attr2 = (0)*32+(12);
    }

    for (int a = 57; a < 57+numArrows; a++) {
        if (arrows[a-57].active == 0) {
            shadowOAM[a].attr0 = (2 << 8);
        } else {
            shadowOAM[a].attr0 = arrows[a-57].row | (0 << 13) | (0 << 14);
        }
        shadowOAM[a].attr1 = arrows[a-57].col | (2 << 14);
        shadowOAM[a].attr2 = (24)*32+(kirby.color);
    }

    for (int l = 73; l < 76; l++) {
        if (playerLives[l-73].active) {
            shadowOAM[l].attr0 = playerLives[l-73].row | (0 << 13) | (0 << 14);
        } else {
            shadowOAM[l].attr0 = (2 << 8);
        }
        shadowOAM[l].attr1 = playerLives[l-73].col | (2 << 14);
        shadowOAM[l].attr2 = (28)*32+(kirby.color);
    }

    shadowOAM[77].attr0 = 30 | (0 << 13) | (0 << 14);
    shadowOAM[77].attr1 = 8 | (2 << 14);
    shadowOAM[77].attr2 = (0)*32+(24);

    shadowOAM[78].attr0 = 34 | (0 << 13) | (0 << 14);
    shadowOAM[78].attr1 = 30 | (0 << 14);
    shadowOAM[78].attr2 = (8)*32+(numOrbsCollected+12);

    if ((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
        goToPause();
    }

    if ((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
        cheatMode = 1;
    }

    if (gameStarted) {
        platforms[0].row = 100;
        platforms[0].col = 0;
        platforms[0].active = 1;

        platforms[1].row = 100;
        platforms[1].col = 60;
        platforms[1].active = 1;

        platforms[2].row = 100;
        platforms[2].col = 120;
        platforms[2].active = 1;

        platforms[3].row = 100;
        platforms[3].col = 180;
        platforms[3].active = 1;

        platforms[4].row = 100;
        platforms[4].col = 30;
        platforms[4].active = 1;

        platforms[5].row = 100;
        platforms[5].col = 90;
        platforms[5].active = 1;

        platforms[6].row = 100;
        platforms[6].col = 150;
        platforms[6].active = 1;

        platforms[7].row = 100;
        platforms[7].col = 210;
        platforms[7].active = 1;

        platforms[8].row = 60;
        platforms[8].col = 40;
        platforms[8].active = 1;

        platforms[9].row = 60;
        platforms[9].col = 170;
        platforms[9].active = 1;

        platforms[10].row = 30;
        platforms[10].col = 100;
        platforms[10].active = 1;

        gameStarted = 0;
    }

    if (cheatMode) {
        if (timer == 10) {
            generatePlatforms();
            generateOrbs();
            if (boo.active) {
                generateRockets();
            }
        } else if (timer == 30) {
            generatePlatforms();
        } else if (timer == 50) {
            generatePlatforms();
            generatePlatforms();
            generateOrbs();
        } else if (timer == 60) {
            generatePlatforms();
            generatePlatforms();
        } else if (timer == 75) {
            generatePlatforms();
        } else if (timer == 100) {
            generatePlatforms();
            generateOrbs();
        } else if (timer == 125) {
            generatePlatforms();
        } else if (timer == 150) {
            timer = 0;
            generatePlatforms();
            generateOrbs();
        } else if (timer == 150 && jumpTimer > 20) {
            boo.row = 0;
            boo.active = 1;
            timer = 0;
            generatePlatforms();
            generateOrbs();
        }
    } else {
        if (timer == 25) {
            generatePlatforms();
            generateOrbs();
            if (boo.active) {
                generateRockets();
            }
        } else if (timer == 65) {
            generateOrbs();
        } else if (timer == 100) {
            generatePlatforms();
            generateOrbs();
        } else if (timer == 150) {
            timer = 0;
            generatePlatforms();
            generateOrbs();
            if (boo.active == 0) {
                boo.row = 0;
                boo.active = 1;
            }

        }
    }

    updatePlayer();
    moveActivePlatforms();
    moveActiveOrbs();
    moveActiveBoo();
    moveActiveRockets();
    moveActiveArrows();
    collisionCheckKirbyPlatform();
    collisionCheckKirbyOrb();

    collisionCheckArrowsBoo();
    checkKirbyOutOfBounds();
    collisionCheckKirbyRocket();
    unpauseBoo();
    checkWin();
    checkLose();
    waitForVblank();
}

void goToPause() {
    vOff = 0;
    *(volatile unsigned short*)0x4000008 = 0 << 2 | 22 << 8 | 0<<14 | 1 << 7;
    loadPalette(pausescreenPal);
    DMANow(3, pausescreenTiles, &((charblock *)0x6000000)[0], (65536 / 2));
    DMANow(3, pausescreenMap, &((screenblock *)0x6000000)[22], (2048 / 2));
    hideSprites();
    state = PAUSESCREEN;
}

void pause() {
    if ((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
        goToGame();
    }
    if ((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
        goToStart();
    }
}

void goToWin() {
    vOff = 0;
    *(volatile unsigned short*)0x4000008 = 0 << 2 | 20 << 8 | 0<<14 | 1 << 7;
    loadPalette(winscreenPal);
    DMANow(3, winscreenTiles, &((charblock *)0x6000000)[0], (65536 / 2));
    DMANow(3, winscreenMap, &((screenblock *)0x6000000)[20], (2048 / 2));
    hideSprites();
    state = WINSCREEN;

}

void win() {
    stopSound();

    if ((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
        goToStart();
    }
}

void goToLose() {
    vOff = 0;
    hideSprites();
    *(volatile unsigned short*)0x4000008 = 0 << 2 | 20 << 8 | 0<<14 | 1 << 7;
    loadPalette(losescreenPal);
    DMANow(3, losescreenTiles, &((charblock *)0x6000000)[0], (65536 / 2));
    DMANow(3, losescreenMap, &((screenblock *)0x6000000)[20], (2048 / 2));
    state=LOSESCREEN;
}

void lose() {
    stopSound();


    if((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
        goToStart();
    }
}

void updatePlayer() {
    kirby.rdel += kirby.racc;

    if(((kirby.row) >> 8)+kirby.height >= 160) {
        kirby.rdel = 0;
        kirby.row = ((160-kirby.height) << 8);
    }

    if(((kirby.row) >> 8) < 0) {
        kirby.rdel = 0;
        kirby.row = kirby.height;
    }

    if((!(~(oldButtons)&((1<<6))) && (~buttons & ((1<<6)))) && jumpTimer > 46) {
        playSoundB(jump, 2857, 11025, 0);
        kirby.rdel = -700;
        jumpTimer = 0;
    }

    if((!(~(oldButtons)&((1<<0))) && (~buttons & ((1<<0))))) {
        attackEnemies();
    }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))) {
        kirby.attacking = 12;
        if(((kirby.col) >> 8) > -4) {
            kirby.col = kirby.col-200;
        }

        kirby.kirbyDirection = 4;
        shadowOAM[0].attr2 = (kirby.attacking)*32+(kirby.color + kirby.kirbyDirection);

    }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))) {
        kirby.attacking = 12;
        if(((kirby.col) >> 8) < 240-kirby.width) {
            kirby.col = kirby.col+200;
        }

        kirby.kirbyDirection = 0;
        shadowOAM[0].attr2 = (kirby.attacking)*32+(kirby.color + kirby.kirbyDirection);
    }

    if (kirby.rdel < 0) {
        shadowOAM[0].attr2 = (16)*32+(kirby.color + kirby.kirbyDirection);
    }

    kirby.row += kirby.rdel;
}

void generatePlatforms() {
    for(int i=0; i<numPlatforms; i++) {
        if(platforms[i].active == 0) {
            platforms[i].active = 1;
            platforms[i].row = 0;
            break;
        }
    }
}

void generateSpikePlatforms() {
    for(int i=0; i<numSpikePlatforms; i++) {
        if(spikePlatforms[i].active == 0) {
            spikePlatforms[i].active = 1;
            spikePlatforms[i].row = 0;
            break;
        }
    }
}

void generateOrbs() {
    for(int i=0; i<numOrbs; i++) {
        if(orbs[i].active == 0) {
            orbs[i].active = 1;
            for (int j=0; j<numPlatforms; j++) {
                int randActivePlatform = rand() % 21;
                if (platforms[randActivePlatform].active == 1) {
                    orbs[i].col = platforms[randActivePlatform].col/2;
                }
            }
            orbs[i].row = 0;
            break;
        }
    }
}

void generateRockets() {
    if (boo.active == 1) {
        boo.direction = 2;
        shadowOAM[45].attr2 = (0)*32+(8);
        for (int i=0; i<numRockets; i++) {
            if(rockets[i].active == 0) {
                rockets[i].active = 1;
                rockets[i].row = boo.row;
                rockets[i].col = boo.col;
                break;
            }
        }
    }
}

void unpauseBoo() {
    if (boo.direction == 2) {
        if (timer % 100 == 0) {
            boo.direction = rand() % 2;
        }
    }
}

void moveActivePlatforms() {
    for(int i=0; i<numPlatforms; i++) {
        if(platforms[i].active == 1 && timer % 3 == 0) {
            platforms[i].row++;
            if(platforms[i].row > 160) {
                platforms[i].active = 0;
            }
        }
    }
}

void moveActiveOrbs() {
    for(int i=0; i<numOrbs; i++) {
        if(orbs[i].active == 1) {
            orbs[i].row++;
            if(orbs[i].row > 160) {
                orbs[i].active = 0;
            }
        }
    }
}

void moveActiveBoo() {
    if (timer % 3 == 0) {
        boo.row++;
    }

    if(boo.active == 1 && boo.direction == 1) {
        if (boo.col >= 240-boo.width) {
            boo.col--;
            boo.direction = 0;
        } else {
            boo.col++;
        }
    } else if (boo.active == 1 && boo.direction == 0) {
        if (boo.col <= 0) {
            boo.col++;
            boo.direction = 1;
        } else {
            boo.col--;
        }
    }

    if(boo.direction == 0) {
        shadowOAM[45].attr2 = (4)*32+(8);
    } else if (boo.direction == 1) {
        shadowOAM[45].attr2 = (8)*32+(8);
    }

    if(boo.row > 240) {
        boo.active = 0;
        boo.row = 0;
    }
}

void moveActiveRockets() {
    for(int i=0; i<numRockets; i++) {
        if(rockets[i].active == 1) {
            rockets[i].row++;
            if(rockets[i].row > 160) {
                rockets[i].active = 0;
            }
        }
    }
}

void moveActiveArrows() {
    for(int i=0; i<numArrows; i++) {
        if(arrows[i].active == 1) {
            arrows[i].row--;
            if(arrows[i].row < 0) {
                arrows[i].active = 0;
            }
        }
    }
}

void attackEnemies() {
    if (timer % 2 == 0) {
        kirby.attacking = 20;
        playSoundB(hit, 11232, 11025, 0);
        for(int i=0; i<numArrows; i++) {
            if(arrows[i].active == 0) {
                arrows[i].active = 1;
                arrows[i].row = ((kirby.row) >> 8);
                arrows[i].col = ((kirby.col) >> 8);
                shadowOAM[i+57].attr0 = arrows[i].row | (0 << 13) | (0 << 14);
                shadowOAM[i+57].attr1 = arrows[i].col;
                break;
            }
        }
    }
}

void collisionCheckKirbyPlatform() {
    for (int i=0; i<numPlatforms; i++) {
        if(platforms[i].active &&
            platforms[i].col <= ((kirby.col) >> 8) + kirby.width &&
            platforms[i].col + platforms[i].width >= ((kirby.col) >> 8) &&
            platforms[i].row <= (((kirby.row) >> 8)+kirby.height) &&
            platforms[i].row >= (((kirby.row) >> 8)+kirby.height-((kirby.rdel) >> 8))) {
            if (kirby.rdel > 0) {
                kirby.rdel = 0;
                kirby.row = ((platforms[i].row) << 8)-((kirby.height) << 8);
            }
        }
    }
}

void collisionCheckKirbyOrb() {
    for (int i=0; i<numOrbs; i++) {
        if(orbs[i].active &&
        orbs[i].col <= ((kirby.col) >> 8) + kirby.width &&
        orbs[i].col + orbs[i].width >= ((kirby.col) >> 8) &&
        orbs[i].row + orbs[i].height >= ((kirby.row) >> 8)) {
            numOrbsCollected++;
            orbs[i].active = 0;
        }
    }
}

void collisionCheckKirbyRocket() {
    for (int i=0; i<numRockets; i++) {
        if(rockets[i].active &&
        rockets[i].col <= ((kirby.col) >> 8) + kirby.width &&
        rockets[i].col + rockets[i].width >= ((kirby.col) >> 8) &&
        rockets[i].row + rockets[i].height >= ((kirby.row) >> 8)) {
            if (firstCollision == 0) {
                playSoundB(lifelost, 52224, 44100, 0);
                rockets[i].active = 0;
                lives = lives - 1;
                playerLives[lives].active = 0;
                shadowOAM[lives+73].attr0 = (2 << 8);
                firstCollision = 1;
            } else if (collisionTimer > 100 && firstCollision == 1) {
                playSoundB(lifelost, 52224, 44100, 0);
                rockets[i].active = 0;
                lives = lives - 1;
                playerLives[lives].active = 0;
                shadowOAM[lives+73].attr0 = (2 << 8);
                collisionTimer = 0;
            }
        }
    }
}

void collisionCheckArrowsBoo() {
    for (int i=0; i<numOrbs; i++) {
        if(arrows[i].active &&
        arrows[i].col <= boo.col + boo.width &&
        arrows[i].col + arrows[i].width >= boo.col &&
        arrows[i].row + arrows[i].height >= boo.row) {
            boo.active = 0;
            boo.row = 0;
        }
    }
}

void collisionCheckKirbyBoo() {
    if(boo.active &&
    boo.col <= ((kirby.col) >> 8) + kirby.width &&
    boo.col + boo.width >= ((kirby.col) >> 8) &&
    boo.row + boo.height >= ((kirby.row) >> 8)) {
        if (collisionTimer > 150) {
            playSoundB(lifelost, 52224, 44100, 0);
            lives = lives - 1;
            playerLives[lives].active = 0;
            collisionTimer = 0;
        }
    }
}

void checkKirbyOutOfBounds() {
    if((((kirby.row) >> 8)+kirby.height >= 160) && collisionTimer > 150) {
        playSoundB(lifelost, 52224, 44100, 0);
        lives = lives - 1;
        playerLives[lives].active = 0;
        collisionTimer = 0;
    }
}

void checkWin() {
    if (numOrbsCollected >= 10) {
        goToWin();
    }
}

void checkLose() {
    if (lives == 0) {
        goToLose();
    }
}
